/**
 * Auto-Mode Changelog Generation
 *
 * Generates AUTOMODE_CHANGELOG.md after auto-mode session completes.
 *
 * @license Apache-2.0
 */
import fs from 'fs-extra';
import path from 'path';
import type {
  AutomodeSessionState,
  AutomodeIterationLog,
  AutomodeStatus,
} from '../types.js';

/** Changelog file name */
const CHANGELOG_FILE = 'AUTOMODE_CHANGELOG.md';

/** Status emoji mapping */
const STATUS_EMOJI: Record<AutomodeStatus, string> = {
  running: 'üîÑ',
  paused: '‚è∏Ô∏è',
  completed: '‚úÖ',
  cancelled: '‚ö†Ô∏è',
  failed: '‚ùå',
};

/** Status text mapping */
const STATUS_TEXT: Record<AutomodeStatus, string> = {
  running: 'Running',
  paused: 'Paused',
  completed: 'Completed successfully',
  cancelled: 'Cancelled',
  failed: 'Failed',
};

/**
 * Generate the auto-mode changelog
 */
export async function generateChangelog(
  workspaceRoot: string,
  state: AutomodeSessionState,
  iterations: AutomodeIterationLog[],
  gitCommits: Array<{ hash: string; message: string }> = []
): Promise<string> {
  const changelogPath = path.join(workspaceRoot, CHANGELOG_FILE);

  // Calculate duration
  const startTime = new Date(state.startedAt);
  const endTime = new Date();
  const durationMs = endTime.getTime() - startTime.getTime();
  const durationMinutes = Math.round(durationMs / 60000);

  // Calculate total tokens and cost
  const totalTokens = iterations.reduce((sum, it) => sum + (it.tokensUsed ?? 0), 0);
  const totalCost = iterations.reduce((sum, it) => sum + (it.cost ?? 0), 0);

  // Build changelog content
  const lines: string[] = [
    '# Auto-Mode Session Report',
    '',
    '## Summary',
    '',
    `- **Task:** ${state.prompt.slice(0, 100)}${state.prompt.length > 100 ? '...' : ''}`,
    `- **Duration:** ${durationMinutes} minutes (${state.currentIteration} iterations)`,
    `- **Result:** ${STATUS_EMOJI[state.status]} ${STATUS_TEXT[state.status]}`,
  ];

  if (state.branch) {
    const merged = state.status === 'completed' ? ' ‚Üí merged to main' : '';
    lines.push(`- **Branch:** ${state.branch}${merged}`);
  }

  if (state.cancelReason && state.status !== 'completed') {
    lines.push(`- **Reason:** ${formatCancelReason(state.cancelReason)}`);
  }

  if (state.errorMessage) {
    lines.push(`- **Error:** ${state.errorMessage}`);
  }

  // Iterations section
  lines.push('', '## Iterations', '');

  for (const iteration of iterations) {
    const time = new Date(iteration.timestamp).toLocaleTimeString();
    lines.push(`### Iteration ${iteration.iteration} (${time})`);
    lines.push('');

    // Actions
    if (iteration.actions.length > 0) {
      for (const action of iteration.actions) {
        lines.push(`- ${action}`);
      }
    } else {
      lines.push('- No actions recorded');
    }

    // Checkpoint
    if (iteration.checkpoint) {
      lines.push('');
      lines.push(`**Checkpoint:** \`${iteration.checkpoint.commit}\` - "${iteration.checkpoint.message}"`);
    }

    // Token usage
    if (iteration.tokensUsed) {
      lines.push('');
      lines.push(`*Tokens: ${iteration.tokensUsed.toLocaleString()}*`);
    }

    lines.push('');
  }

  // Final state section
  lines.push('## Final State', '');
  lines.push(`- **Files Created:** ${state.filesCreated}`);
  lines.push(`- **Files Modified:** ${state.filesModified}`);
  lines.push(`- **Total Iterations:** ${state.currentIteration}`);

  if (totalTokens > 0) {
    lines.push(`- **Total Tokens:** ${totalTokens.toLocaleString()}`);
  }
  if (totalCost > 0) {
    lines.push(`- **Estimated Cost:** $${totalCost.toFixed(2)}`);
  }

  // Commits section
  if (gitCommits.length > 0) {
    lines.push('', '## Commits Made', '');
    gitCommits.forEach((commit, index) => {
      lines.push(`${index + 1}. \`${commit.hash}\` - ${commit.message}`);
    });
  }

  // Footer
  lines.push('', '---', '');
  lines.push(`*Generated by autohand auto-mode on ${endTime.toISOString()}*`);
  lines.push('');

  const content = lines.join('\n');

  // Write changelog
  await fs.writeFile(changelogPath, content, 'utf-8');

  return changelogPath;
}

/**
 * Append to existing changelog (for multiple sessions)
 */
export async function appendToChangelog(
  workspaceRoot: string,
  state: AutomodeSessionState,
  iterations: AutomodeIterationLog[],
  gitCommits: Array<{ hash: string; message: string }> = []
): Promise<string> {
  const changelogPath = path.join(workspaceRoot, CHANGELOG_FILE);

  // Check if changelog exists
  const exists = await fs.pathExists(changelogPath);

  if (!exists) {
    return generateChangelog(workspaceRoot, state, iterations, gitCommits);
  }

  // Read existing content
  const existingContent = await fs.readFile(changelogPath, 'utf-8');

  // Generate new session report
  const newReport = await generateSessionReport(state, iterations, gitCommits);

  // Prepend new report after main header
  const headerEnd = existingContent.indexOf('\n## Summary');
  if (headerEnd === -1) {
    // No existing summary, just prepend
    const newContent = newReport + '\n---\n\n' + existingContent;
    await fs.writeFile(changelogPath, newContent, 'utf-8');
  } else {
    // Insert before first Summary
    const header = existingContent.slice(0, headerEnd);
    const rest = existingContent.slice(headerEnd);
    const newContent = header + '\n' + newReport + '\n---\n' + rest;
    await fs.writeFile(changelogPath, newContent, 'utf-8');
  }

  return changelogPath;
}

/**
 * Generate a session report section
 */
async function generateSessionReport(
  state: AutomodeSessionState,
  iterations: AutomodeIterationLog[],
  gitCommits: Array<{ hash: string; message: string }> = []
): Promise<string> {
  const startTime = new Date(state.startedAt);
  const endTime = new Date();
  const durationMs = endTime.getTime() - startTime.getTime();
  const durationMinutes = Math.round(durationMs / 60000);

  const lines: string[] = [
    `## Session: ${state.sessionId}`,
    '',
    `- **Task:** ${state.prompt.slice(0, 80)}${state.prompt.length > 80 ? '...' : ''}`,
    `- **Started:** ${startTime.toISOString()}`,
    `- **Duration:** ${durationMinutes} minutes`,
    `- **Iterations:** ${state.currentIteration}`,
    `- **Result:** ${STATUS_EMOJI[state.status]} ${STATUS_TEXT[state.status]}`,
  ];

  if (state.branch) {
    lines.push(`- **Branch:** ${state.branch}`);
  }

  if (gitCommits.length > 0) {
    lines.push('', '**Commits:**');
    gitCommits.forEach(commit => {
      lines.push(`- \`${commit.hash}\` ${commit.message}`);
    });
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Format cancel reason for display
 */
function formatCancelReason(reason: string): string {
  const reasonMap: Record<string, string> = {
    user_escape: 'User pressed ESC',
    user_cancel: 'User cancelled via command',
    hook_cancel: 'Cancelled by hook',
    rpc_cancel: 'Cancelled via RPC',
    acp_cancel: 'Cancelled via ACP',
    max_iterations: 'Maximum iterations reached',
    max_runtime: 'Maximum runtime exceeded',
    max_cost: 'Maximum cost exceeded',
    circuit_breaker: 'Circuit breaker triggered',
    completion: 'Completion promise detected',
    error: 'Error occurred',
  };
  return reasonMap[reason] ?? reason;
}

/**
 * Get changelog path
 */
export function getChangelogPath(workspaceRoot: string): string {
  return path.join(workspaceRoot, CHANGELOG_FILE);
}

/**
 * Check if changelog exists
 */
export async function changelogExists(workspaceRoot: string): Promise<boolean> {
  return fs.pathExists(getChangelogPath(workspaceRoot));
}
