# Autohand 0.8.0 में नया क्या है

Autohand 0.8.0 एक प्रमुख रिलीज़ है जो Unix वर्कफ़्लो के लिए पाइप मोड, विस्तारित सोच नियंत्रण, ग्रैन्युलर ऑटो-अप्रूव (yolo मोड), MCP क्लाइंट सपोर्ट, IDE इंटीग्रेशन, प्लान मोड और बहुत कुछ लेकर आता है। यह दस्तावेज़ इस रिलीज़ में शामिल हर नई सुविधा और सुधार को कवर करता है।

## विषय सूची

- [पाइप मोड](#पाइप-मोड)
- [विस्तारित सोच](#विस्तारित-सोच)
- [सेशन इतिहास](#सेशन-इतिहास)
- [ग्रैन्युलर ऑटो-अप्रूव (Yolo मोड)](#ग्रैन्युलर-ऑटो-अप्रूव-yolo-मोड)
- [MCP क्लाइंट सपोर्ट](#mcp-क्लाइंट-सपोर्ट)
- [IDE इंटीग्रेशन](#ide-इंटीग्रेशन)
- [Homebrew इंस्टॉलेशन](#homebrew-इंस्टॉलेशन)
- [प्लान मोड](#प्लान-मोड)
- [Web Repo टूल](#web-repo-टूल)
- [ऑटो कॉन्टेक्स्ट कम्पैक्शन](#ऑटो-कॉन्टेक्स्ट-कम्पैक्शन)
- [कस्टम सिस्टम प्रॉम्प्ट](#कस्टम-सिस्टम-प्रॉम्प्ट)
- [नए CLI फ़्लैग](#नए-cli-फ़्लैग)
- [नए स्लैश कमांड](#नए-स्लैश-कमांड)
- [आर्किटेक्चर सुधार](#आर्किटेक्चर-सुधार)
- [अपग्रेड कैसे करें](#अपग्रेड-कैसे-करें)

---

## पाइप मोड

Autohand अब Unix पाइपलाइन के हिस्से के रूप में सहजता से काम करता है। जब stdin TTY नहीं है, तो Autohand **पाइप मोड** में प्रवेश करता है -- यह कम्पोज़ेबल वर्कफ़्लो के लिए डिज़ाइन किया गया एक नॉन-इंटरैक्टिव एक्ज़ीक्यूशन पाथ है।

### यह कैसे काम करता है

पाइप मोड पाइप किए गए कंटेंट को आपके इंस्ट्रक्शन के साथ LLM को भेजता है। अंतिम परिणाम stdout पर लिखा जाता है, जबकि एरर और प्रोग्रेस stderr पर जाते हैं। इससे डाउनस्ट्रीम कंज़्यूमर्स के लिए आउटपुट स्ट्रीम साफ़ रहता है।

```bash
# एक diff की व्याख्या करें
git diff | autohand 'explain these changes'

# फ़ाइल से कोड रिव्यू करें
cat src/auth.ts | autohand 'review this code for security issues'

# कई टूल्स को चेन करें
git log --oneline -10 | autohand 'summarize recent changes' > changelog.txt
```

### आउटपुट रूटिंग

| स्ट्रीम | कंटेंट |
|----------|---------|
| **stdout** | केवल अंतिम परिणाम (डाउनस्ट्रीम पाइप्स द्वारा उपभोग) |
| **stderr** | एरर और वैकल्पिक प्रोग्रेस मैसेज |

### JSON आउटपुट

प्रोग्रामैटिक कंज़म्पशन के लिए स्ट्रक्चर्ड ndjson आउटपुट हेतु `--json` का उपयोग करें:

```bash
git diff | autohand 'review' --json
```

हर लाइन एक वैलिड JSON ऑब्जेक्ट है:

```json
{"type": "result", "content": "diff दिखाता है..."}
{"type": "error", "message": "रेट लिमिट से अधिक"}
```

### विस्तृत प्रोग्रेस

stdout को साफ़ रखते हुए प्रोग्रेस मैसेज stderr पर भेजने के लिए `--verbose` का उपयोग करें:

```bash
git diff | autohand 'review' --verbose 2>progress.log
```

### कम्पोज़ेबल उदाहरण

```bash
# पाइप चेन: टेस्ट जेनरेट करें, फिर lint
autohand --prompt 'generate tests for auth.ts' | eslint --stdin

# xargs के साथ उपयोग
find src -name '*.ts' | xargs -I{} sh -c 'cat {} | autohand "review" > {}.review'

# CI इंटीग्रेशन
git diff HEAD~1 | autohand 'check for breaking changes' --json | jq '.content'
```

---

## विस्तारित सोच

`--thinking` फ़्लैग के साथ LLM की प्रतिक्रिया देने से पहले की रीज़निंग गहराई को नियंत्रित करें। यह स्पीड और थोरोनेस के बीच संतुलन बनाने में उपयोगी है।

### उपयोग

```bash
# जटिल कार्यों के लिए विस्तारित रीज़निंग
autohand --thinking extended

# स्टैंडर्ड रीज़निंग (डिफ़ॉल्ट)
autohand --thinking normal

# दिखाई देने वाली रीज़निंग के बिना सीधे जवाब
autohand --thinking none

# शॉर्टकट: बिना वैल्यू के --thinking extended पर डिफ़ॉल्ट होता है
autohand --thinking
```

### सोच के स्तर

| स्तर | विवरण | सबसे अच्छा उपयोग |
|------|--------|-------------------|
| `extended` | विस्तृत विचार प्रक्रिया के साथ गहन रीज़निंग | जटिल रीफैक्टरिंग, आर्किटेक्चर निर्णय, डिबगिंग |
| `normal` | स्टैंडर्ड रीज़निंग गहराई (डिफ़ॉल्ट) | सामान्य कोडिंग कार्य |
| `none` | दिखाई देने वाली रीज़निंग के बिना सीधे जवाब | सरल प्रश्न, त्वरित संपादन |

### एनवायरनमेंट वेरिएबल

IDE इंटीग्रेशन के लिए उपयोगी, एनवायरनमेंट वेरिएबल के माध्यम से भी सोच का स्तर सेट किया जा सकता है:

```bash
AUTOHAND_THINKING_LEVEL=extended autohand --prompt "refactor this module"
```

---

## सेशन इतिहास

नया `/history` स्लैश कमांड सेशन इतिहास का पेजिनेटेड ब्राउज़िंग प्रदान करता है, जिससे पिछले काम को खोजना और फिर से शुरू करना आसान हो जाता है।

### उपयोग

```
/history          # सेशन इतिहास का पहला पेज दिखाएं
/history 2        # पेज 2 दिखाएं
/history 3        # पेज 3 दिखाएं
```

### प्रदर्शन फ़ॉर्मेट

हर एंट्री में दिखाया जाता है:

| कॉलम | विवरण |
|-------|--------|
| **ID** | सेशन आइडेंटिफ़ायर (20 कैरेक्टर तक ट्रंकेटेड) |
| **तारीख** | निर्माण तारीख और समय |
| **प्रोजेक्ट** | प्रोजेक्ट का नाम |
| **मॉडल** | उपयोग किया गया LLM मॉडल (संक्षिप्त) |
| **मैसेज** | कुल मैसेज संख्या |
| **स्टेटस** | एक्टिव सेशन बैज (हरा `[active]`) |

### सेशन फिर से शुरू करना

सुचारू वर्कफ़्लो के लिए `/history` को `/resume` के साथ मिलाएं:

```
/history            # वांछित सेशन खोजें
/resume abc123...   # उसे फिर से शुरू करें
```

---

## ग्रैन्युलर ऑटो-अप्रूव (Yolo मोड)

Yolo मोड टूल कॉल्स के पैटर्न-आधारित ऑटो-अप्रूवल प्रदान करता है, जिससे आप एजेंट बिना पूछे क्या कर सकता है इस पर बारीक नियंत्रण रख सकते हैं। समय-सीमित स्वायत्त सेशन के लिए `--timeout` के साथ मिलाएं।

### उपयोग

```bash
# सब कुछ ऑटो-अप्रूव करें
autohand --yolo true

# केवल रीड और राइट ऑपरेशन ऑटो-अप्रूव करें
autohand --yolo 'allow:read_file,write_file,search'

# डिलीट और कमांड एक्ज़ीक्यूशन को छोड़कर सब कुछ ऑटो-अप्रूव करें
autohand --yolo 'deny:delete_path,run_command'

# सभी ऑपरेशन अनुमति दें, लेकिन केवल 10 मिनट के लिए
autohand --yolo true --timeout 600
```

### पैटर्न सिंटैक्स

| पैटर्न | प्रभाव |
|--------|--------|
| `true` | `allow:*` का शॉर्टकट -- सब कुछ अप्रूव करें |
| `allow:*` | सभी टूल्स ऑटो-अप्रूव करें |
| `allow:read_file,write_file` | केवल सूचीबद्ध टूल्स ऑटो-अप्रूव करें |
| `deny:delete_path,run_command` | सूचीबद्ध टूल्स को अस्वीकार करें, बाकी ऑटो-अप्रूव करें |

### यह कैसे काम करता है

1. Autohand `--yolo` पैटर्न को `YoloPattern` (मोड + टूल लिस्ट) में पार्स करता है।
2. जब किसी टूल कॉल को अप्रूवल की ज़रूरत होती है, Autohand चेक करता है कि टूल का नाम पैटर्न से मैच करता है या नहीं।
3. अगर मैच होता है (allow मोड में) या नहीं होता है (deny मोड में), तो टूल बिना पूछे एक्ज़ीक्यूट होता है।
4. अगर पैटर्न टूल को ऑटो-अप्रूव नहीं करता, तो सामान्य परमिशन प्रॉम्प्ट दिखाया जाता है।

### टाइमर

`--timeout` फ़्लैग शेष समय को ट्रैक करने वाला `YoloTimer` बनाता है:

```bash
# 5 मिनट के लिए ऑटो-अप्रूव, फिर सामान्य प्रॉम्प्टिंग पर वापस
autohand --yolo true --timeout 300
```

- जब तक टाइमर सक्रिय है, मैचिंग टूल्स ऑटो-अप्रूव होते हैं।
- जब टाइमर समाप्त होता है, सभी टूल कॉल्स सामान्य परमिशन प्रॉम्प्टिंग पर लौटते हैं।

### सुरक्षा

- Yolo मोड मौजूदा परमिशन सिस्टम के साथ इंटीग्रेट होता है।
- ब्लैकलिस्टेड ऑपरेशन (`permissions.blacklist`) yolo मोड में भी ब्लॉक रहते हैं।
- `deny` पैटर्न आपको खतरनाक ऑपरेशन को स्पष्ट रूप से बाहर करने देता है।

---

## MCP क्लाइंट सपोर्ट

Autohand में अब एक बिल्ट-इन MCP (Model Context Protocol) क्लाइंट शामिल है जो बाहरी MCP सर्वर से कनेक्ट कर सकता है। इससे आप डेटाबेस, API, या किसी भी MCP-कम्पैटिबल सर्विस के कस्टम टूल्स के साथ Autohand को एक्सटेंड कर सकते हैं।

### अवलोकन

MCP AI एजेंट्स को बाहरी टूल्स से जोड़ने के लिए एक इंडस्ट्री स्टैंडर्ड प्रोटोकॉल है। Autohand का MCP क्लाइंट निम्नलिखित सपोर्ट करता है:

- **stdio ट्रांसपोर्ट** -- एक चाइल्ड प्रोसेस शुरू करता है और stdin/stdout पर JSON-RPC 2.0 के माध्यम से संवाद करता है
- **SSE ट्रांसपोर्ट** -- Server-Sent Events का उपयोग करके HTTP सर्वर से कनेक्ट होता है
- **ऑटोमैटिक टूल डिस्कवरी** -- `tools/list` क्वेरी करता है और डायनामिकली टूल्स रजिस्टर करता है
- **नेमस्पेस्ड टूल्स** -- टकराव से बचने के लिए टूल्स को `mcp__<सर्वर>__<टूल>` प्रीफ़िक्स दिया जाता है
- **सर्वर लाइफ़साइकल मैनेजमेंट** -- सर्वर शुरू करना, बंद करना और रीकनेक्ट करना

### कॉन्फ़िगरेशन

अपने `~/.autohand/config.json` में MCP सर्वर जोड़ें:

```json
{
  "mcp": {
    "servers": [
      {
        "name": "database",
        "transport": "stdio",
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-postgres"],
        "env": {
          "DATABASE_URL": "postgresql://localhost/mydb"
        },
        "autoConnect": true
      },
      {
        "name": "custom-api",
        "transport": "sse",
        "url": "http://localhost:3001/mcp",
        "autoConnect": true
      }
    ]
  }
}
```

### सर्वर कॉन्फ़िगरेशन फ़ील्ड

| फ़ील्ड | टाइप | आवश्यक | डिफ़ॉल्ट | विवरण |
|--------|------|---------|----------|--------|
| `name` | string | हां | - | सर्वर का यूनिक नाम |
| `transport` | `"stdio"` या `"sse"` | हां | - | कनेक्शन प्रकार |
| `command` | string | केवल stdio | - | सर्वर शुरू करने का कमांड |
| `args` | string[] | नहीं | `[]` | कमांड आर्ग्युमेंट्स |
| `url` | string | केवल sse | - | SSE एंडपॉइंट URL |
| `env` | object | नहीं | `{}` | सर्वर प्रोसेस के एनवायरनमेंट वेरिएबल्स |
| `autoConnect` | boolean | नहीं | `true` | स्टार्टअप पर ऑटोमैटिकली कनेक्ट |

### टूल नेमिंग

MCP टूल्स बिल्ट-इन टूल्स के साथ टकराव रोकने के लिए नेमस्पेस का उपयोग करते हैं:

```
mcp__<सर्वर-नाम>__<टूल-नाम>
```

उदाहरण के लिए, `database` नाम के सर्वर से `query` नाम का टूल `mcp__database__query` बन जाता है।

---

## IDE इंटीग्रेशन

`/ide` कमांड आपके सिस्टम पर चल रहे IDE को डिटेक्ट करता है और इंटीग्रेटेड फ़ीचर्स को सक्षम करता है। Autohand पता लगा सकता है कि कौन सा IDE आपके वर्तमान वर्कस्पेस को एडिट कर रहा है और प्रासंगिक एक्सटेंशन सुझा सकता है।

### सपोर्टेड IDE

| IDE | प्लेटफ़ॉर्म | एक्सटेंशन उपलब्ध |
|-----|-------------|-------------------|
| Visual Studio Code | macOS, Linux, Windows | हां |
| Visual Studio Code Insiders | macOS, Linux, Windows | हां |
| Cursor | macOS, Linux, Windows | नहीं |
| Zed | macOS, Linux, Windows | हां |
| Antigravity | macOS | नहीं |

### उपयोग

```
/ide
```

कमांड निम्नलिखित चरण करता है:

1. ज्ञात IDE पैटर्न के लिए चल रही प्रोसेसेज़ को स्कैन करता है
2. हर इंस्टेंस ने कौन सा वर्कस्पेस खोला है यह जानने के लिए IDE स्टोरेज पढ़ता है
3. डिटेक्टेड IDE को आपकी वर्तमान वर्किंग डायरेक्टरी से मैच करता है
4. मैचिंग IDE के लिए सिलेक्शन मोडल प्रस्तुत करता है
5. गहरी इंटीग्रेशन के लिए एक्सटेंशन इंस्टॉलेशन सुझाता है

---

## Homebrew इंस्टॉलेशन

Autohand अब macOS पर Homebrew के माध्यम से उपलब्ध है:

```bash
# सीधे इंस्टॉल करें
brew install autohand

# या ऑफ़िशियल tap के माध्यम से
brew tap autohandai/tap && brew install autohand
```

### विवरण

- Node.js को डिपेंडेंसी के रूप में घोषित किया गया है और ज़रूरत पड़ने पर ऑटो-इंस्टॉल होता है
- फ़ॉर्मूला npm रजिस्ट्री से इंस्टॉल करता है
- इंस्टॉलेशन के बाद `autohand --version` से वर्शन वेरिफ़ाई होता है
- `brew upgrade autohand` से अपडेट उपलब्ध हैं

---

## प्लान मोड

प्लान मोड एजेंट को कार्य करने से पहले योजना बनाने देता है। सक्षम होने पर, एजेंट जानकारी एकत्र करने और योजना तैयार करने के लिए केवल रीड-ओनली टूल्स का उपयोग करता है। एक बार जब आप योजना को मंजूरी दे देते हैं, तो एक्ज़ीक्यूशन शुरू होता है।

### एक्टिवेशन

प्लान मोड को चालू/बंद करने के लिए **Shift+Tab** दबाएं। एक स्टेटस इंडिकेटर वर्तमान स्थिति दिखाता है:

| इंडिकेटर | अर्थ |
|----------|------|
| `[PLAN]` | प्लानिंग फ़ेज़ -- एजेंट जानकारी एकत्र कर रहा है और योजना बना रहा है |
| `[EXEC]` | एक्ज़ीक्यूशन फ़ेज़ -- एजेंट मंजूर योजना को लागू कर रहा है |
| *(कोई नहीं)* | प्लान मोड बंद -- सामान्य ऑपरेशन |

### यह कैसे काम करता है

1. **एक्टिवेट** -- Shift+Tab दबाएं। प्रॉम्प्ट `[PLAN]` दिखाता है।
2. **प्लानिंग फ़ेज़** -- एजेंट केवल रीड-ओनली टूल्स का उपयोग कर सकता है (फ़ाइल रीडिंग, सर्च, git status, वेब सर्च, आदि)। राइट ऑपरेशन ब्लॉक होते हैं।
3. **योजना प्रस्तुतिकरण** -- एजेंट चरणों के साथ एक स्ट्रक्चर्ड प्लान प्रस्तुत करता है।
4. **स्वीकृति विकल्प** -- आगे कैसे बढ़ना है चुनें:
   - **कॉन्टेक्स्ट क्लियर करें और एडिट्स ऑटो-एक्सेप्ट करें** -- सर्वश्रेष्ठ प्लान पालन, बातचीत का इतिहास क्लियर करता है
   - **मैन्युअल अप्रूव** -- हर एडिट को अलग से रिव्यू और अप्रूव करें
   - **ऑटो-एक्सेप्ट** -- बिना रिव्यू के सभी एडिट्स ऑटो-एक्सेप्ट करें
5. **एक्ज़ीक्यूशन** -- इंडिकेटर `[EXEC]` में बदल जाता है और एजेंट प्लान लागू करता है।

---

## Web Repo टूल

नया `web_repo` टूल `@owner/repo` फ़ॉर्मेट का उपयोग करके GitHub और GitLab से रिपॉज़िटरी जानकारी प्राप्त करता है। इससे एजेंट को टर्मिनल छोड़े बिना बाहरी रिपॉज़िटरी का कॉन्टेक्स्ट मिलता है।

### उपयोग

अपने प्रॉम्प्ट में `@owner/repo` सिंटैक्स का उपयोग करके एक रिपॉज़िटरी का उल्लेख करें:

```
मुझे @vercel/next.js के बारे में बताएं
```

एजेंट रिपॉज़िटरी मेटाडेटा, README कंटेंट और स्ट्रक्चर जानकारी प्राप्त करने के लिए `web_repo` टूल को सीधे भी कॉल कर सकता है।

---

## ऑटो कॉन्टेक्स्ट कम्पैक्शन

Autohand अब सेशन लंबे होने पर बातचीत के कॉन्टेक्स्ट को ऑटोमैटिकली कम्पैक्ट करता है। इससे कॉन्टेक्स्ट विंडो की थकावट रोकती है और लंबे सेशन के दौरान एजेंट की प्रतिक्रियाशीलता बनी रहती है।

### यह कैसे काम करता है

- डिफ़ॉल्ट रूप से सक्षम (`--cc` फ़्लैग)
- मॉडल की कॉन्टेक्स्ट विंडो के सापेक्ष बातचीत की लंबाई की निगरानी करता है
- जब बातचीत सीमा के करीब पहुंचती है, पुराने मैसेज सारांशित और कम्पैक्ट किए जाते हैं
- इंटरैक्टिव मोड और प्लान मोड दोनों में काम करता है
- महत्वपूर्ण जानकारी (फ़ाइल कंटेंट, हाल के टूल रिज़ल्ट) संरक्षित रहती है

### कॉन्फ़िगरेशन

```bash
# कॉन्टेक्स्ट कम्पैक्शन सक्षम करें (डिफ़ॉल्ट)
autohand --cc

# कॉन्टेक्स्ट कम्पैक्शन अक्षम करें
autohand --no-cc
```

---

## कस्टम सिस्टम प्रॉम्प्ट

विशेष वर्कफ़्लो के लिए डिफ़ॉल्ट सिस्टम प्रॉम्प्ट को ओवरराइड या एक्सटेंड करें।

### पूरा प्रॉम्प्ट बदलें

```bash
# इनलाइन स्ट्रिंग
autohand --sys-prompt "You are a Python expert. Be concise."

# फ़ाइल से
autohand --sys-prompt ./custom-prompt.md
```

`--sys-prompt` का उपयोग करने पर, डिफ़ॉल्ट Autohand निर्देश, AGENTS.md, मेमोरी और स्किल्स सभी बदल दिए जाते हैं।

### डिफ़ॉल्ट प्रॉम्प्ट में जोड़ें

```bash
# इनलाइन स्ट्रिंग
autohand --append-sys-prompt "Always use TypeScript instead of JavaScript"

# फ़ाइल से
autohand --append-sys-prompt ./team-guidelines.md
```

`--append-sys-prompt` का उपयोग करने पर, कंटेंट पूरे डिफ़ॉल्ट प्रॉम्प्ट के अंत में जोड़ दिया जाता है। सभी डिफ़ॉल्ट व्यवहार संरक्षित रहते हैं।

---

## नए CLI फ़्लैग

| फ़्लैग | विवरण |
|--------|--------|
| `--thinking [level]` | रीज़निंग गहराई सेट करें: `none`, `normal`, `extended` |
| `--yolo [pattern]` | पैटर्न से मैच करने वाले टूल कॉल्स ऑटो-अप्रूव करें |
| `--timeout <seconds>` | yolo मोड ऑटो-अप्रूव के लिए समय सीमा |
| `--cc` / `--no-cc` | ऑटोमैटिक कॉन्टेक्स्ट कम्पैक्शन सक्षम/अक्षम करें |
| `--search-engine <provider>` | वेब सर्च प्रोवाइडर सेट करें (`brave`, `duckduckgo`, `parallel`) |
| `--sys-prompt <value>` | पूरा सिस्टम प्रॉम्प्ट बदलें (इनलाइन या फ़ाइल पाथ) |
| `--append-sys-prompt <value>` | डिफ़ॉल्ट सिस्टम प्रॉम्प्ट में जोड़ें |
| `--display-language <locale>` | डिस्प्ले भाषा सेट करें (जैसे, `en`, `zh-cn`, `fr`, `de`, `ja`) |
| `--add-dir <path>` | वर्कस्पेस स्कोप में अतिरिक्त डायरेक्टरी जोड़ें |
| `--skill-install [name]` | कम्युनिटी स्किल इंस्टॉल करें |
| `--project` | प्रोजेक्ट लेवल पर स्किल इंस्टॉल करें (`--skill-install` के साथ) |

---

## नए स्लैश कमांड

| कमांड | विवरण |
|-------|--------|
| `/history` | पेजिनेशन के साथ सेशन इतिहास ब्राउज़ करें |
| `/history <पेज>` | सेशन इतिहास का विशिष्ट पेज देखें |
| `/ide` | चल रहे IDE डिटेक्ट करें और इंटीग्रेशन के लिए कनेक्ट करें |
| `/about` | Autohand के बारे में जानकारी दिखाएं (वर्शन, लिंक) |
| `/feedback` | CLI के बारे में फ़ीडबैक भेजें |
| `/plan` | प्लान मोड के साथ इंटरैक्ट करें |
| `/add-dir` | वर्कस्पेस स्कोप में अतिरिक्त डायरेक्टरी जोड़ें |
| `/language` | डिस्प्ले भाषा बदलें |
| `/formatters` | उपलब्ध कोड फ़ॉर्मेटर्स की सूची |
| `/lint` | उपलब्ध कोड लिंटर्स की सूची |
| `/completion` | शेल कम्प्लीशन स्क्रिप्ट्स जेनरेट करें (bash, zsh, fish) |
| `/export` | सेशन को markdown, JSON या HTML में एक्सपोर्ट करें |
| `/permissions` | परमिशन सेटिंग्स देखें और मैनेज करें |
| `/hooks` | लाइफ़साइकल हुक्स इंटरैक्टिवली मैनेज करें |
| `/share` | autohand.link के माध्यम से सेशन शेयर करें |
| `/skills` | स्किल्स की सूची देखें, एक्टिवेट, डीएक्टिवेट या बनाएं |

---

## आर्किटेक्चर सुधार

### Modal कंपोनेंट

`enquirer` डिपेंडेंसी को Ink पर बनाए गए कस्टम `Modal` कंपोनेंट से बदल दिया गया है। इससे एक समान स्टाइलिंग, कीबोर्ड नेविगेशन और TUI के बाकी हिस्सों के साथ बेहतर इंटीग्रेशन मिलता है।

### एक्सट्रैक्टेड मॉड्यूल

बेहतर कंसर्न सेपरेशन के लिए कई आंतरिक मॉड्यूल एक्सट्रैक्ट किए गए हैं:

- **WorkspaceFileCollector** -- 30 सेकंड कैशिंग के साथ वर्कस्पेस फ़ाइल डिस्कवरी हैंडल करता है
- **AgentFormatter** -- टर्मिनल डिस्प्ले के लिए एजेंट आउटपुट फ़ॉर्मेट करता है
- **ProviderConfigManager** -- प्रोवाइडर-विशिष्ट कॉन्फ़िगरेशन लॉजिक मैनेज करता है

### Ink UI रेंडरिंग

प्रायोगिक Ink-आधारित रेंडरर (`ui.useInkRenderer`) को निम्नलिखित के लिए ऑप्टिमाइज़ किया गया है:

- React रीकन्सिलिएशन के माध्यम से फ़्लिकर-फ़्री आउटपुट
- काम करने वाली रिक्वेस्ट क्यू (एजेंट काम करते समय टाइप करें)
- readline कॉन्फ़्लिक्ट के बिना बेहतर इनपुट हैंडलिंग

### डायनामिक हेल्प

`/help` कमांड अब रजिस्टर्ड स्लैश कमांड्स से डायनामिकली अपना आउटपुट जेनरेट करता है, इसलिए यह हमेशा उपलब्ध कमांड्स के वर्तमान सेट को दर्शाता है।

---

## अपग्रेड कैसे करें

### npm से

```bash
npm update -g autohand-cli
```

### Homebrew से

```bash
brew upgrade autohand
```

### कॉन्फ़िगरेशन कम्पैटिबिलिटी

आपका मौजूदा `~/.autohand/config.json` पूरी तरह से बैकवर्ड-कम्पैटिबल है। किसी माइग्रेशन की ज़रूरत नहीं है।

नए कॉन्फ़िगरेशन सेक्शन (जैसे `mcp.servers`) वैकल्पिक हैं और केवल तभी ज़रूरी हैं जब आप संबंधित फ़ीचर्स का उपयोग करना चाहते हैं। Autohand सभी नई सेटिंग्स के लिए उचित डिफ़ॉल्ट्स का उपयोग करता है।

---

## संबंधित दस्तावेज़

- [कॉन्फ़िगरेशन संदर्भ](./config-reference_hi.md) -- सभी कॉन्फ़िगरेशन विकल्प
- [हुक्स सिस्टम](./hooks.md) -- लाइफ़साइकल हुक्स
- [प्रोवाइडर गाइड](./providers.md) -- LLM प्रोवाइडर सेटअप
- [ऑटो मोड](./automode.md) -- स्वायत्त डेवलपमेंट लूप
- [RPC प्रोटोकॉल](./rpc-protocol.md) -- प्रोग्रामैटिक नियंत्रण
